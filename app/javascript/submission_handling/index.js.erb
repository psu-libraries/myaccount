 function submissionHandling() {
        const buttons = document.querySelectorAll(`input[type=submit]`);
        buttons.forEach( function(b){
            b.onclick = function() {
                let checkboxes = document.querySelectorAll('input#hold_list_.checkbox')
                _.each(checkboxes, function(c) {
                    if (c.checked) {
                        console.log('i ran');
                        let spinner = `<div class="spinner-border" role="status">
                                         <span class="sr-only">Loading...</span>
                                       </div>`
                        document.querySelector(`#hold${c.value} .pickup_at`).innerHTML = spinner;
                    }
                });
                let holdIds = _.compact(
                                 _.map(checkboxes, function(c) {
                                    if (c.checked) { return c.value }
                                 })
                              );
                _.each(holdIds, function(h) {
                    renderData(h);
                });
            }
        });
    }

    async function renderData(h) {
        await pollFetch(h);
        deleteData(h);
        return
    }

    function wait(ms = 1000) {
        return new Promise(resolve => {
            console.log(`waiting ${ms} ms...`);
            setTimeout(resolve, ms);
        });
    }

    async function pollFetch(holdId) {
     let endTime = Number(new Date()) + 20000;

      try {
        let result = await getJobInfo(holdId);
        while (checkResults(result) && Number(new Date()) < endTime) {
          await wait(1000);
            console.log('here2');
          result = await getJobInfo(holdId);
        }

        updateDOM(result);
      }
      catch {
          console.log('failure')
      }
    }

    function updateDOM(data) {
        document.querySelector(`#hold${data.hold_id} .pickup_at`).innerHTML = data.new_value;
    }

    async function getJobInfo(holdId) {
        console.log('here1');
        let response = await fetch(`/redis_jobs/${holdId}`);
        let data = await response.json();
        return data;
    }

    function checkResults(data) {
        console.log(data);
      if (data) {
        if (data.result === 'success' || data.result === 'failure') {
// add a delete of the redis key once it has been processed              fetch(`/redis_jobs/${holdId}`)
            return false;
        }
          console.log('result is false2');
          return true;
      }
      console.log('result is false');
      return true;
    }

    async function deleteData(item) {
    console.log('deletion');
        await fetch(`/redis_jobs/${item}`, { method: 'delete'});
        return;
    }
//
export default submissionHandling

// boneyard:
//
//   //try {
//       let response = await fetch(`/redis_jobs/${holdId}`);
//       let data = await response.json();
//       console.log(response);
//       if (!processResults(data)) {
//           setTimeout(fetchResult, 10000);
//           wait();
//       } else {
//           end();
//       }
//   }
//   catch (error) {
//       console.log("There was an error");
//   }

//
//     // Usage:  ensure element is visible
//     poll(function() {
//       const response = fetch(`/redis_jobs/${holdId}`);
//       const json = response.json;
//       processResults(json);
//     }, 10000, 150).then(function() {
//         console.log('things worked')
//         // Polling done, now do something else!
//     }).catch(function() {
//         console.log('uh oh')
//         // Polling timed out, handle the error!
//     });

//},


// The polling function (stole this from David Walsh https://davidwalsh.name/javascript-polling)
//   poll: function(fn, timeout, interval) {
//       let endTime = Number(new Date()) + (timeout || 2000);
//       interval = interval || 100;

//  //     let checkCondition = function(resolve, reject) {
//           // If the condition is met, we're done!
//           let result = fn();
//           if (result) {
//               resolve(result);
//           }
//           // If the condition isn't met but the timeout hasn't elapsed, go again
//           else if (Number(new Date()) < endTime) {
//               setTimeout(checkCondition, interval, resolve, reject);
//           }
//           // Didn't match and too much time, reject!
//           else {
//               reject(new Error('timed out for ' + fn + ': ' + arguments));
//           }
//       };

//       return new Promise(checkCondition);
//   },