# frozen_string_literal: true

# Common accessors into bib item data
#
# Note: Redis and SymphonyClient used in private method to dynamically retrieve and store item type code
# translations.
module BibRecord
  def catkey
    fields.dig('bib', 'key') || item.dig('bib', 'key')
  end

  def item_type_code
    item.dig('itemType', 'key')
  end

  def item_type_human
    item_type_mapping.find { |type| type.dig('key') == item_type_code }&.dig('fields', 'description') || item_type_code
  end

  def title
    bib['title']
  end

  def author
    bib['author']
  end

  # The OR is used in hold requests, generated by bib calls to symphony's web service
  def call_number
    call['dispCallNumber'] || fields['dispCallNumber']
  end

  def resource
    fields.dig('item', 'resource')
  end

  def item_key
    fields.dig('item', 'key')
  end

  def bib_summary
    "#{title} (#{call_number})"
  end

  def shadowed?
    bib['shadowed']
  end

  private

    def item
      fields.dig('item', 'fields') || {}
    end

    def bib
      fields.dig('bib', 'fields') || fields.dig('item', 'fields', 'bib', 'fields') || {}
    end

    def call
      item.dig('call', 'fields') || {}
    end

    # Use Redis to store this globally once an hour
    def item_type_mapping
      redis = Redis.new
      return JSON.parse(redis.get('item_type_map')) unless redis.get('item_type_map').nil?

      client = SymphonyClient.new
      redis.setex('item_type_map', 3600, client.get_item_type_map.to_json)
      JSON.parse(redis.get('item_type_map'))
    end
end
